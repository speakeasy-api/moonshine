#!/usr/bin/env node

const fs = require('fs')
const path = require('path')
const postcss = require('postcss')

// Paths
const UTILITIES_CSS = path.join(__dirname, '../src/utilities.css')
const BASE_CSS = path.join(__dirname, '../src/base.css')
const CLAUDE_MD = path.join(__dirname, '../CLAUDE.md')
const TYPES_DIR = path.join(__dirname, '../types')
const UTILITIES_TYPES = path.join(TYPES_DIR, 'utilities.d.ts')

// Ensure types directory exists
if (!fs.existsSync(TYPES_DIR)) {
  fs.mkdirSync(TYPES_DIR)
}

// Parse CSS and extract utilities
async function extractUtilities(cssPath) {
  if (!fs.existsSync(cssPath)) {
    console.error(`CSS file not found: ${cssPath}`)
    return []
  }

  const css = fs.readFileSync(cssPath, 'utf8')

  let ast
  try {
    ast = postcss.parse(css)
  } catch (error) {
    console.error(`Error parsing CSS file ${cssPath}:`, error.message)
    return []
  }

  const utilities = []

  ast.walkAtRules('utility', (rule) => {
    const name = rule.params.trim()

    // Extract the CSS properties
    const properties = []
    rule.walkDecls((decl) => {
      // Skip nested rules (like @variant)
      if (decl.parent === rule) {
        properties.push(`  ${decl.prop}: ${decl.value};`)
      }
    })

    // Check for variant rules (like dark mode)
    const variants = []
    rule.walkAtRules('variant', (variantRule) => {
      const variantProps = []
      variantRule.walkDecls((decl) => {
        variantProps.push(`    ${decl.prop}: ${decl.value};`)
      })
      variants.push({
        name: variantRule.params.trim(),
        properties: variantProps,
      })
    })

    utilities.push({
      name,
      properties,
      variants,
      raw: rule.toString(),
    })
  })

  return utilities
}

// Extract theme colors that are exposed as utilities
async function extractThemeColors(cssPath) {
  const css = fs.readFileSync(cssPath, 'utf8')
  const ast = postcss.parse(css)
  const colors = new Set()

  ast.walkAtRules('theme', (rule) => {
    rule.walkDecls((decl) => {
      if (decl.prop.startsWith('--color-') && !decl.prop.includes('*')) {
        const colorName = decl.prop.replace('--color-', '')
        // Only include semantic colors, not raw values
        if (
          !colorName.match(
            /^(brand|neutral|destructive|warning|success|info)-\d+$/
          )
        ) {
          colors.add(colorName)
        }
      }
    })
  })

  return Array.from(colors)
}

// Generate TypeScript definitions
function generateTypeDefinitions(utilities, themeColors) {
  const utilityTypes = utilities.map((u) => `  | '${u.name}'`).join('\n')

  // Generate color utility types
  const colorPrefixes = ['bg', 'text', 'border', 'ring', 'divide']
  const colorUtilities = themeColors
    .flatMap((color) =>
      colorPrefixes.map((prefix) => `  | '${prefix}-${color}'`)
    )
    .join('\n')

  return `/**
 * Auto-generated TypeScript definitions for Moonshine utilities
 * Generated on: ${new Date().toISOString()}
 *
 * DO NOT EDIT THIS FILE DIRECTLY
 * Run 'pnpm generate:docs' to update
 */

/**
 * Custom utility classes defined in utilities.css
 */
export type MoonshineUtilities =
${utilityTypes};

/**
 * Semantic color utilities available from theme
 * These are auto-generated from theme colors with standard prefixes
 */
export type MoonshineColorUtilities =
${colorUtilities};

/**
 * All available Moonshine utility classes
 */
export type MoonshineClasses = MoonshineUtilities | MoonshineColorUtilities;

/**
 * Helper type for className props
 */
export type MoonshineClassName = MoonshineClasses | MoonshineClasses[] | undefined | null | false;
`
}

// Generate documentation section for CLAUDE.md
function generateDocSection(utilities) {
  const sections = []

  // Group utilities by type
  const typography = utilities.filter(
    (u) => u.name.startsWith('text-') || u.name.startsWith('typography-')
  )
  const backgrounds = utilities.filter((u) => u.name.startsWith('bg-'))
  const borders = utilities.filter((u) => u.name.startsWith('border-'))
  const other = utilities.filter(
    (u) =>
      !u.name.startsWith('text-') &&
      !u.name.startsWith('typography-') &&
      !u.name.startsWith('bg-') &&
      !u.name.startsWith('border-')
  )

  sections.push('## Available Utility Classes\n')
  sections.push(
    'This section is auto-generated from the CSS files. Last updated: ' +
      new Date().toISOString() +
      '\n'
  )

  // Typography
  if (typography.length > 0) {
    sections.push('### Typography Utilities\n')
    typography.forEach((u) => {
      sections.push(`#### \`${u.name}\`\n`)
      sections.push('```css')
      sections.push(`.${u.name} {`)
      sections.push(u.properties.join('\n'))

      if (u.variants.length > 0) {
        u.variants.forEach((v) => {
          sections.push(`\n  /* ${v.name} variant */`)
          sections.push(v.properties.join('\n'))
        })
      }

      sections.push('}')
      sections.push('```\n')
    })
  }

  // Backgrounds
  if (backgrounds.length > 0) {
    sections.push('### Background Utilities\n')
    backgrounds.forEach((u) => {
      sections.push(`#### \`${u.name}\`\n`)
      sections.push('```css')
      sections.push(`.${u.name} {`)
      sections.push(u.properties.join('\n'))

      if (u.variants.length > 0) {
        u.variants.forEach((v) => {
          sections.push(`\n  /* ${v.name} variant */`)
          sections.push(v.properties.join('\n'))
        })
      }

      sections.push('}')
      sections.push('```\n')
    })
  }

  // Borders
  if (borders.length > 0) {
    sections.push('### Border Utilities\n')
    borders.forEach((u) => {
      sections.push(`#### \`${u.name}\`\n`)
      sections.push('```css')
      sections.push(`.${u.name} {`)
      sections.push(u.properties.join('\n'))
      sections.push('}')
      sections.push('```\n')
    })
  }

  // Other
  if (other.length > 0) {
    sections.push('### Other Utilities\n')
    other.forEach((u) => {
      sections.push(`#### \`${u.name}\`\n`)
      sections.push('```css')
      sections.push(`.${u.name} {`)
      sections.push(u.properties.join('\n'))
      sections.push('}')
      sections.push('```\n')
    })
  }

  return sections.join('\n')
}

// Update CLAUDE.md with generated content
function updateClaudeMd(newContent) {
  const claudeMd = fs.readFileSync(CLAUDE_MD, 'utf8')

  // Find the section to replace
  const startMarker = '## Available Utility Classes'
  const endMarker = '## Migration Notes'

  const startIndex = claudeMd.indexOf(startMarker)
  let endIndex = claudeMd.indexOf(endMarker)

  // If end marker not found, look for the next ## heading
  if (endIndex === -1) {
    const afterStart = claudeMd.substring(startIndex + startMarker.length)
    const nextHeadingMatch = afterStart.match(/\n## /)
    if (nextHeadingMatch) {
      endIndex = startIndex + startMarker.length + nextHeadingMatch.index + 1
    }
  }

  if (startIndex === -1) {
    console.error(
      'Could not find "## Available Utility Classes" section in CLAUDE.md'
    )
    console.error(
      'Please ensure CLAUDE.md contains this section for auto-generation to work'
    )
    return
  }

  if (endIndex === -1 || endIndex <= startIndex) {
    // No end marker found, append to end of file
    const updated = claudeMd + '\n\n' + newContent
    fs.writeFileSync(CLAUDE_MD, updated, 'utf8')
    console.log('   Appended to end of CLAUDE.md (no end marker found)')
  } else {
    const before = claudeMd.substring(0, startIndex)
    const after = claudeMd.substring(endIndex)
    const updated = before + newContent + '\n' + after
    fs.writeFileSync(CLAUDE_MD, updated, 'utf8')
  }
}

// Main function
async function main() {
  console.log('ðŸŽ¨ Generating Moonshine utility documentation...\n')

  try {
    // Extract utilities
    console.log('ðŸ“– Reading utilities.css...')
    const utilities = await extractUtilities(UTILITIES_CSS)
    console.log(`   Found ${utilities.length} utility classes`)

    // Extract theme colors
    console.log('ðŸŽ¨ Reading theme colors from utilities.css...')
    const themeColors = await extractThemeColors(UTILITIES_CSS)
    console.log(`   Found ${themeColors.length} theme colors`)

    // Generate TypeScript definitions
    console.log('\nðŸ“ Generating TypeScript definitions...')
    const typeDefs = generateTypeDefinitions(utilities, themeColors)
    fs.writeFileSync(UTILITIES_TYPES, typeDefs, 'utf8')
    console.log(
      `   Written to ${path.relative(process.cwd(), UTILITIES_TYPES)}`
    )

    // Generate documentation
    console.log('\nðŸ“š Generating documentation...')
    const docSection = generateDocSection(utilities)
    updateClaudeMd(docSection)
    console.log(`   Updated ${path.relative(process.cwd(), CLAUDE_MD)}`)

    console.log('\nâœ… Documentation generation complete!')
    console.log('\nðŸ’¡ Tip: Import the types in your components:')
    console.log(
      '   import type { MoonshineClasses } from "@speakeasy-api/moonshine/types/utilities"'
    )
  } catch (error) {
    console.error('\nâŒ Error generating documentation:', error)
    process.exit(1)
  }
}

// Run the script
main()
